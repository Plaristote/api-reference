Helper class generating HTML forms for Models. The `FormBuilder` template class creates &lt;form&gt; and its &lt;input&gt; elements with _scoped_ names.

#### Creating a FormBuilder

The `MODEL` template parameter requires a type that _must_ expose the following:

- A `scope` static field with the [std::string] or `const char*` type. The scope field will be used to identify forms targeting this type.
- A `get_id() const` method, returning either [std::string], or any type that can be converted to [std::string] using [boost::lexical_cast](https://www.boost.org/doc/libs/master/doc/html/boost_lexical_cast.html).
- A `is_persistent() const` method, returning `true` if the form should be editing an existing model, or `false` if it is creating a new model.

Example:

```c++
class MyModel
{
  long long id = 0;
public:
  static constexpr char* scope = "mymodel";

  long long get_id() const { return id; }

  bool is_persistent() const { return id > 0; }
};
```

You may then use `FormBuilder` in your HTML templates:

```html
MyModel @model;
FormBuilder<MyModel> form(this, model);

// END LINKING
<%= form_for(model, "/my-route") yields %>
  <%= form.label("myfield") %>
<% yields-end %>
```

#### Name scopes

All inputs generated by `FormBuilder` use a name scope based on the `MODEL::scope`. For instance, if the scope defined in the `MODEL` type is `"mymodel"`, then the name for the `myfield` field would be `mymodel[myfield]`. For instance:

```c++
<%= form.label_for("myfield") yields %>
  My Field
<% yields-end %>
<%= form.text_field("myfield", &MyModel::get_my_filed) %>
```

Generates the following HTML:

```html
<label for="mymodel[myfield]">
  My Field
</label>
<input type="text" name="mymodel[myfield]" />
```
